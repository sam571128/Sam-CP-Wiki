---
description: 覺得遞迴很麻煩嗎? 想要用很短的 code 寫出線段樹嗎? 那就來試試看迭代型線段樹吧!
---

# 迭代型線段樹 (ZKW)

在閱讀這篇文章前，建議先去學習遞迴型的線段樹。本節內容可能會預設讀者已經會遞迴版本的線段樹。

![平常我們寫的線段樹](../../.gitbook/assets/zkw\_segment\_tree.png)

### 為什麼要用迭代型的線段樹?

迭代型線段樹（又名 zkw 線段樹），事實上就是把我們平常寫的遞迴型線段樹，用迴圈的方式實作。而這樣子的線段樹，雖然比起遞迴型，可能並沒有那麼直覺。不過實際了解過後，會發現程式碼寫起來十分短，甚至在遞迴型的線段樹得到 TLE 時，可以做為其中一種壓常的方法。

### 建立方式

首先，我們先從最簡單的操作開始說起吧。與遞迴版本的線段樹十分相似，我們先假設現在陣列的數字數量是 $$2^k$$。那麼，我們就會建立出一棵完美二元樹。

由於我們的結構是一棵完美二元樹，這種二元樹的特點是，當我們放到陣列上時。編號方式十分簡單。假設目前節點的編號為 $$i$$，則左孩子的編號為 $$2i$$，右孩子的編號為 $$2i+1$$。

到目前為止的部分大致上都與遞迴版本相同。不過，讓我們觀察一下這棵樹

![](../../.gitbook/assets/zkw\_array.png)

如上圖，我們可以發現，假設原本的陣列（假設是$$a$$）長度為 $$n$$，則$$a[i]$$的值，會被存在線段樹上，編號為 $$i+n-1$$ 的位置上。

而剩下的節點，其實我們只要從下往上，從左右孩子合併資料即可

因此，我們得到了這棵線段樹的建立方式，十分簡單

{% code lineNumbers="true" %}
```cpp
const int N = 1e5+5;
int tr[N*2], arr[N];

void init(int n){
    for(int i = 1;i <= n;i++){
        tr[i+n-1] = arr[i];
    }
    for(int i = n-1;i >= 1;i--){
        tr[i] = combine(tr[i<<1], tr[i<<1|1]);
    }
}
```
{% endcode %}

### 區間詢問

接著，我們先來談談，如何尋找區間 $$[l,r]$$ 的答案吧

![](../../.gitbook/assets/zkw\_query.png) ![](../../.gitbook/assets/zkw\_query\_2.png)

觀察一下上面這兩張圖，我們會發現幾件事情

1. 對於一個區間 $$[l,r]$$，我們會將其拆成一些樹上節點，使得這些節點包含所有$$[l,r]$$ 內的元素
2. 當 $$l$$ 是左孩子時，他或者他的祖先會被詢問到。反之，他的祖先不會被詢問到
3. 當 $$r$$是右孩子時，他或者他的祖先會被詢問到。反之，他的祖先不會被詢問到

根據上面幾點觀察，我們可以寫出一個很神奇的區間查詢的程式碼

```cpp
int query(int l, int r){
    int sum = 0;
    for(l+=n-1, r+=n-1;l <= r;l>>=1,r>>=1){
        if(l&1) sum += t[l++];
        if(r&1^1) sum += t[r--];
    }
    return sum;
}
```
